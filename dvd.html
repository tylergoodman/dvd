<!doctype html>
<html>

<head>
  <style>
    html,
    body {
      background-color: black;
      height: 100%;
      line-height: 0;
      margin: 0;
    }

    p {
      color: #CDCDCD;
      font-weight: bold;
      position: absolute;
      left: 20px;
      top: 20px;
      white-space: pre;
      line-height: 1;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <canvas></canvas>
  <p></p>
  <p id="permLog"></p>
  <script src="./rxjs.umd.min.js" type="text/javascript"></script>
  <script>
    'use strict';

    window.wallpaperPropertyListener = {
      applyUserProperties(properties) {
        // permLog(JSON.stringify(properties, null, 2));
        if (properties.showstats) {
          setSavedSetting('showStats', properties.showstats.value);
        }
        if (properties.showtimetocorner) {
          setSavedSetting('showTimeToCorner', properties.showtimetocorner.value);
        }
        if (properties.showdebuginfo) {
          setSavedSetting('showDebugInfo', properties.showdebuginfo.value);
        }
        if (properties.backgroundImage) {
          // settings.backgroundImage = 
          // TODO custom non-dvd logo
        }
        if (properties.resetcounters) {
          if (properties.resetcounters.value) {
            resetCounters();
          }
        }
      },
    };
    
    const statsEl = document.querySelector('p');
    const stats = new rxjs.Subject();
    const statsData = new Map();
    stats.pipe(
        rxjs.scan(([oldValues], newValues) => {
          let hasChanged = false;
          for (const [newKey, newValue] of newValues) {
            if (newValue === undefined) {
              oldValues.delete(newKey);
              return;
            }
            const oldValue = oldValues.get(newKey);
            if (!oldValues.has(newKey) || oldValue !== newValue) {
              oldValues.set(newKey, newValue);
              hasChanged = true;
            }
          }
          return [oldValues, hasChanged];
        }, [statsData, false]),
        rxjs.distinctUntilChanged((_, [,hasChanged]) => !hasChanged),
        rxjs.map(([values]) => {
          const statsToDisplay = [];
          for (const [displayText, value] of values) {
            statsToDisplay.push(`${displayText}: ${value}`);
          }
          return statsToDisplay.join('\n');
        }))
        .subscribe(statsToDisplay => {
          statsEl.innerText = statsToDisplay;
        });
    function flushStats() {
      statsData.clear();
      statsEl.innerText = '';
    }
    const permLogEl = document.querySelector('#permLog');
    function permLog(string) {
      const child = document.createElement('p');
      child.innerText = string;
      permLogEl.appendChild(child);
    }

    const settings = {
      showStats: true,
      showTimeToCorner: true,
      showDebugInfo: true,
    };
    const statsSettings = new Map([
      ['wallsHit', 'Walls hit'],
      ['cornersHit', 'Corners hit'],
    ]);
    settings.wallsHit = Number.parseInt(localStorage.getItem('wallsHit'), 10) || 0;
    settings.cornersHit = Number.parseInt(localStorage.getItem('cornersHit'), 10) || 0;
    if (settings.showStats) {
      stats.next([
        [statsSettings.get('wallsHit'), settings.wallsHit],
        [statsSettings.get('cornersHit'), settings.cornersHit],
      ]);
    }
    function setSavedSetting(key, value) {
      const oldValue = settings[key];
      if (value === oldValue) return;
      settings[key] = value;
      localStorage.setItem(key, value);
      if (settings.showStats && statsSettings.has(key)) {
        stats.next([[statsSettings.get(key), value]]);
      }
    }
    function resetCounters() {
      localStorage.setItem('wallsHit', 0);
      localStorage.setItem('cornersHit', 0);
      settings.wallsHit = 0;
      settings.cornersHit = 0;
    }

    const canvas = document.querySelector('canvas');

    class BouncingImage {
      hue = 0;

      position = { x: 0, y: 0 };

      imageSrc = undefined;
      imageData = undefined;
      imageDimensions = { x: 0, y: 0 };
      direction = 1;
      totalD = 0;
      currD = 0;

      tick(count) {
        this._tickPosition(count);
        this._tickColor(count);
      }

      draw(ctx) {
        ctx.putImageData(this.imageData, this.position.x, this.position.y);
      }

      get canvasWidth() {
        return canvas.width - this.imageDimensions.x;
      }
      get canvasHeight() {
        return canvas.height - this.imageDimensions.y;
      }

      _getUniverse(d) {
        return {
          x: Math.floor(d / this.canvasWidth),
          y: Math.floor(d / this.canvasHeight),
        };
      }

      /**
       * This article helped me figure this out:
       *    http://lostmathlessons.blogspot.com/2016/03/bouncing-dvd-logo.html
       */
      _tickPosition(count) {
        const PIXELS_PER_MILLISECOND = 1;
        const MAX_TICK_COUNT = 10000;
        if (count > MAX_TICK_COUNT) {
          count = 1;
        }
        
        const prevD = this.currD;
        this.currD = prevD + (count * PIXELS_PER_MILLISECOND * this.direction);
        let cornerHit = false;
        // If we went far out of bounds, bounce back an equal amount.
        if (this.currD >= this.totalD) {
          const delta = this.currD - this.totalD;
          this.currD = this.totalD - delta;
          cornerHit = true;
        }
        if (this.currD <= 0) {
          const delta = Math.abs(this.currD);
          this.currD = delta;
          cornerHit = true;
        }
        if (cornerHit) {
          this.direction *= -1;
          setSavedSetting('cornersHit', settings.cornersHit + 1);
        }

        const prevUniverse = this._getUniverse(prevD);
        const universe = this._getUniverse(this.currD);
        const universeDelta = Math.abs(universe.x - prevUniverse.x) +
            Math.abs(universe.y - prevUniverse.y);
        if (!cornerHit && universeDelta) {
          setSavedSetting('wallsHit', settings.wallsHit + universeDelta);
        }

        const universeOffset = {
          x: universe.x * this.canvasWidth,
          y: universe.y * this.canvasHeight,
        };
        const delta = {
          x: this.currD - universeOffset.x,
          y: this.currD - universeOffset.y,
        };
        this.position = {
          x: universe.x % 2 === 0 ? delta.x : this.canvasWidth - delta.x,
          y: universe.y % 2 === 0 ? delta.y : this.canvasHeight - delta.y,
        };

        if (settings.showTimeToCorner) {
          const distanceToCorner = this.direction === 1 ?
              this.totalD - this.currD : this.currD;
          const pixelsPerSecond = PIXELS_PER_MILLISECOND * 1000;
          const timeToCorner = distanceToCorner / pixelsPerSecond;
          const formattedTimeToCorner = timeToCorner.toLocaleString('en-US', {
            style: 'unit',
            unit: 'second',
            maximumSignificantDigits: 3,
          });
          stats.next([['Time to corner', formattedTimeToCorner]]);
        }

        if (settings.showDebugInfo) {
          stats.next([
            ['X', this.position.x],
            ['Y', this.position.y],
            ['Universe X', universe.x],
            ['Universe Y', universe.y],
            ['Universe offset X', universeOffset.x],
            ['Universe offset Y', universeOffset.y],
            ['Delta X', delta.x],
            ['Delta Y', delta.y],
            ['D', this.currD],
            ['Total D', this.totalD],
            ['Direction', this.direction],
          ]);
        }
      }

      _tickColor(count) {
        this._tickHue(count);

        const {data} = this.imageData;
        const [r, g, b] = hslToRgb(this.hue);
        for (let i = 0; i < data.length; i += 4) {
          data[i]     = r;
          data[i + 1] = g;
          data[i + 2] = b;
        }
      }

      _tickHue(count) {
        const COLOR_SPEED = 0.05;
        let hue = this.hue * 360;
        hue += count * COLOR_SPEED;
        if (hue > 360) {
          hue -= 360;
        }
        this.hue = hue / 360;
      }

      resize() {
        const heightDelta = canvas.height - this.imageDimensions.y;
        const widthDelta = canvas.width - this.imageDimensions.x;
        this.totalD = lcm(heightDelta, widthDelta);
      }

      static fromFile(fileName) {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = fileName;
        return new Promise((resolve, reject) => {
          try {
            img.addEventListener('load', () => {
              const canvas = document.createElement('canvas');
              canvas.style.background = 'red';
              const width = img.naturalWidth;
              const height = img.naturalHeight;
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);

              const ret = new this();
              ret.imageSrc = fileName;
              ret.imageData = ctx.getImageData(0, 0, width, height);
              ret.imageDimensions = {x: width, y: height};
              resolve(ret);
            });
          } catch (e) {
            reject(e);
          }
        });
      }
    }

    const ctx = canvas.getContext('2d');
    const objects = [];
    let curFrame = performance.now();
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const now = performance.now();
      const deltaTime = now - curFrame;
      for (const object of objects) {
        object.tick(deltaTime);
        object.draw(ctx);
      }

      curFrame = now;
      requestAnimationFrame(loop);
    }
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      for (const object of objects) {
        object.resize();
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      Promise.all([
        BouncingImage.fromFile('DVD_logo.svg'),
      ]).then(objs => {
        objects.push(...objs);
        resize();
        requestAnimationFrame(loop);
      });
    });

    window.addEventListener('resize', () => {
      resize();
    });

    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     *
     * @param   {number}  h       The hue
     * @param   {number}  s       The saturation
     * @param   {number}  l       The lightness
     * @return  {Array}           The RGB representation
     */
    function hslToRgb(h, s = 0.5, l = 0.5){
        var r, g, b;

        if(s == 0){
            r = g = b = l; // achromatic
        }else{
            var hue2rgb = function hue2rgb(p, q, t){
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    function gcd(a,b){
      var t = 0;
      a < b && (t = b, b = a, a = t); // swap them if a < b
      t = a%b;
      return t ? gcd(b,t) : b;
    }
    function lcm(a,b){
      return a/gcd(a,b)*b;
    }
    function isEqual(a, b) {
      return a === b;
    }
    function arrayEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (!isEqual(a[i], b[i])) return false;
      }
      return true;
    }
    function objectEquals(a, b) {
      if (a === b) return true;
      const aKeys = Object.keys(a);
      const bKeys = new Set(Object.keys(b));
      if (aKeys.length !== bKeys.size) return false;
      for (const aKey of aKeys) {
        const aValue = a[aKey];
        const bValue = b[bKey];
        if (aValue !== bValue) return false;
        bKeys.delete(aKey);
      }
      if (bKeys.size) return false;
      return true;
    }
    function clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }
    function memoize(fn) {
      let lastArgs;
      let lastValue;
      return function () {
        if (!lastArgs || !arrayEqual(lastArgs, arguments)) {
          lastArgs = arguments;
          lastValue = fn.apply(null, arguments);
        }
        return lastValue;
      };
    }
  </script>
</body>

</html>